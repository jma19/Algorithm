#### 467. Unique Substrings in Wraparound String
Consider the string s to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so s will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....". Your job is to find out how many unique non-empty substrings of p are present in s. In particular, your input is the string p and you need to output the number of different non-empty substrings of p in the string s.

**Note**: p consists of only lowercase English letters and the size of p might be over 10000.

**Examples:**

~~~
Input: "a"
Output: 1

Explanation: Only the substring "a" of string "a" is in the string s.

Input: "cac"
Output: 2
Explanation: There are two substrings "a", "c" of string "cac" in the string s.

Input: "zab"
Output: 6
Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.
~~~

#### Analysis

The ideas can be summaried in the following points. 

1. A single character should have minimum number of unqiue substring 1
2. The maximum number of unique ends with a letter equals to the maximum continous substring ends with that letter. 
e.g: "abcdefcdef", the maximum number of uqique substring ends with 'f' is 6 (abcdef). We use a Integer type array with size 26 to contains the maximum number of unique substring ends with letter ('a' + index)
3. Two characters are continous, which means ch[i] - ch[i-1] = 1, or ch[i-1] - ch[i] = 25 (z - a)

Based on above ideas, we have:

~~~

public int findSubstringInWraproundString(String p) {
        if(p == null){
            return 0;
        }
        int len = p.length();
        if(len < 2){
            return len;
        }
        int[] res = new int[26];
        int maxLen = 0;
        for(int i = 0; i < len; i++){
            //continus substring
            if(i > 0 && (p.charAt(i) - p.charAt(i-1) == 1 || p.charAt(i-1) - p.charAt(i) == 25)){
                maxLen++;
            }
            else{
                maxLen = 1;
            }
            int index = p.charAt(i) - 'a';
            res[index] = Math.max(res[index], maxLen);
        }
        int sum = 0;
        for(int i = 0; i < 26; i++){
            sum += res[i];
        }
        return sum;
    }
~~~


